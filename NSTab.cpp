/*
 * Copyright (c) 2012, Georgia Tech Research Corporation
 * All rights reserved.
 *
 * Humanoid Robotics Lab      Georgia Institute of Technology
 * Director: Mike Stilman     http://www.golems.org
 */

#include <wx/wx.h>
#include <GUI/Viewer.h>
#include <GUI/GUI.h>
#include <GUI/GRIPSlider.h>
#include <GUI/GRIPFrame.h>
#include <Tabs/GRIPTab.h>
#include <string>
#include <iostream>

#include <Tabs/AllTabs.h>
#include <GRIPApp.h>

#include "NSTab.h"

using namespace std;

// Control IDs (used for event handling - be sure to start with a non-conflicted id)
enum NSTabEvents {

  button_SetCurrentConfig,
  button_ShowCurrentConfig,
  button_UpdateTime,
  
  slider_NS1,
  slider_NS2,
  slider_NS3,
  slider_NS4,
  
};


// sizer for whole tab
wxBoxSizer* sizerFull;

//Add a handler for any events that can be generated by the widgets you add here (sliders, radio, checkbox, etc)
BEGIN_EVENT_TABLE( NSTab, wxPanel )
EVT_COMMAND ( wxID_ANY, wxEVT_GRIP_SLIDER_CHANGE, NSTab::OnSlider )
EVT_COMMAND ( wxID_ANY, wxEVT_COMMAND_BUTTON_CLICKED, NSTab::OnButton )
EVT_COMMAND( wxID_ANY, wxEVT_COMMAND_RADIOBOX_SELECTED, NSTab::OnRadio )
END_EVENT_TABLE()

// Class constructor for the tab: Each tab will be a subclass of RSTTab
IMPLEMENT_DYNAMIC_CLASS( NSTab, GRIPTab )

/**
 * @function NSTab
 * @brief Constructor
 */
NSTab::NSTab( wxWindow *parent, const wxWindowID id,
	      const wxPoint& pos, const wxSize& size, long style) :
GRIPTab(parent, id, pos, size, style ) {

  mCurrentConfig.resize(0);

  
  mRobotId = 0;
  mLinks.resize(0);

  mEEName = "LJ6";

  sizerFull = new wxBoxSizer( wxHORIZONTAL );
 
  // ** Create left static box for configuring the planner **
  
  // Create StaticBox container for all items
  wxStaticBox* configureBox = new wxStaticBox(this, -1, wxT("Configuration"));
  
  // Create sizer for start buttons in 1st column
  wxStaticBoxSizer *configureBoxSizer = new wxStaticBoxSizer(configureBox, wxVERTICAL);
  configureBoxSizer->Add( new wxButton(this, button_SetCurrentConfig, wxT("Set &Current Conf")), 1, wxEXPAND | wxALL, 3 );
  configureBoxSizer->Add( new wxButton(this, button_ShowCurrentConfig, wxT("Show Current Conf")), 1, wxEXPAND | wxALL, 3 ); 
  
  sizerFull->Add( configureBoxSizer, 1, wxEXPAND | wxALL, 6 );

  // ** Create right static box for running the planner **
  wxStaticBox* slidersBox = new wxStaticBox(this, -1, wxT("NS Sliders"));

  // Create sizer for this box
  wxStaticBoxSizer* slidersBoxSizer = new wxStaticBoxSizer(slidersBox, wxVERTICAL);

  // Add
  mNS[0] = new GRIPSlider( "NS1", -30, 30, 60, 1, 10, 30, this, slider_NS1 );  // changed this
  slidersBoxSizer->Add( mNS[0], 1, wxEXPAND | wxALL, 3 );

  mNS[1] = new GRIPSlider( "NS2", -30, 30, 60, 1, 10, 30, this, slider_NS2 ); 
  slidersBoxSizer->Add( mNS[1], 1, wxEXPAND | wxALL, 3 );
 
  mNS[2] = new GRIPSlider( "NS3", -30, 30, 30, 1, 1, 30, this, slider_NS3 ); 
  slidersBoxSizer->Add( mNS[2], 1, wxEXPAND | wxALL, 3 );

  mNS[3] = new GRIPSlider( "NS4", -30, 30, 30, 1, 1, 30, this, slider_NS4 ); 
  slidersBoxSizer->Add( mNS[3], 1, wxEXPAND | wxALL, 3 );

  sizerFull->Add( slidersBoxSizer, 1, wxEXPAND | wxALL, 6);
  
  SetSizer(sizerFull);
}


/**
 * @function ~NSTab
 * @brief Destructor
 */ 
NSTab::~NSTab(){
}

/**
 * @function getLeftArmIds
 * @brief Get DOF's IDs for ROBINA's left arm
 */
Eigen::VectorXi NSTab::GetLeftArmIds() {

  mEENode = mWorld->mRobots[mRobotId]->getNode( mEEName.c_str() );
  mEEId = mEENode->getSkelIndex();
  
  string LINK_NAMES[7] = {"LJ0", "LJ1", "LJ2", "LJ3", "LJ4", "LJ5", "LJ6" };
  
  Eigen::VectorXi linksAll = mWorld->mRobots[mRobotId]->getQuickDofsIndices(); 

  Eigen::VectorXi linksLeftArm(7);
  for( unsigned int i = 0; i < 7; i++ ) {
    for( unsigned int j = 0; j < linksAll.size(); j++ ) {      
      if( mWorld->mRobots[mRobotId]->getDof( linksAll[j] )->getJoint()->getChildNode()->getName() == LINK_NAMES[i] ) {
	linksLeftArm[i] = linksAll[j]; 
	break;   
      }
    }
  }
  
  return linksLeftArm;
}

/**
 * @function setTimeLine
 * @brief 
 */
void NSTab::SetTimeline( std::vector<Eigen::VectorXd> _path ) {
    
  if( mWorld == NULL || _path.size() == 0 ) {
    std::cout << "--(!) Must create a valid plan before updating its duration (!)--" << std::endl;
    return;
  }
  
  double T;
  timeText->GetValue().ToDouble(&T);
    
  int numsteps = _path.size();
  double increment = T/(double)numsteps;
  
  cout << "-->(+) Updating Timeline - Increment: " << increment << " Total T: " << T << " Steps: " << numsteps << endl;
  
    frame->InitTimer( string("Plan"),increment );
    
    
    Eigen::VectorXd vals( mLinks.size() );
    
    for( size_t i = 0; i < numsteps; ++i ) {
      mWorld->mRobots[mRobotId]->setDofs( _path[i], mLinks );
      mWorld->mRobots[mRobotId]->update();
      
      frame->AddWorld( mWorld );
    }
    
}

/**
 * @function OnButton
 * @brief Handle Button Events
 */
void NSTab::OnButton(wxCommandEvent &evt) {

    int button_num = evt.GetId();
    mLinks = GetLeftArmIds();
    
    switch (button_num) {
      
      /** Set Current Configuration */
    case button_SetCurrentConfig: {
	  
      if ( mWorld != NULL ) {
	if( mWorld->mRobots.size() < 1) {
	  std::cout << "--(!) Must have a world with a robot to set a Current config (!)--" << std::endl;
	  break;
	}
	std::cout << "--(i) Setting Current Config for " << mWorld->mRobots[mRobotId]->getName() << ":" << std::endl;	
	SetCurrentConfig();

      } else {
	std::cout << "--(!) Must have a world loaded to set a Current config(!)--" << std::endl;
      }
    }
      break;


      /** Show Current Config */
    case button_ShowCurrentConfig: {
      
      if( mCurrentConfig.size() < 1 ) {
	std::cout << "--(x) First, set a current configuration (x)--" << std::endl;
	break;
      } 
      
      mWorld->mRobots[mRobotId]->setDofs( mCurrentConfig, mLinks );
      
      for( unsigned int i = 0; i< mCurrentConfig.size(); i++ )
	{  std::cout << mCurrentConfig(i) << " "; }
      std::cout << std::endl;
      
      mWorld->mRobots[mRobotId]->update();
      viewer->UpdateCamera();
    }
      break;

      /** UpdateTime */
    case button_UpdateTime:
      {
	/// Update the time span of the movie timeline
	//SetTimeline();
      }		
      break;
      
    } // end of switch
}


/**
 * @function RunOnSliderChange
 */
void NSTab::RunOnSliderChange( int _coeff, double _value ) {

  mNS_Coeff( _coeff, _coeff ) = _value; 

  Eigen::VectorXd mTemp;
  mTemp = mCurrentConfig;

  for( int i = 0; i < mNS_Dim; ++i ) {
    mTemp = mTemp + mNS_Basis.col(i)*mNS_Coeff(i,i);
  }

  mWorld->mRobots[mRobotId]->setDofs( mTemp, mLinks );
        
  mWorld->mRobots[mRobotId]->update();
  viewer->UpdateCamera();
      
}

/**
 * @function setCurrentConfig  
 */
void NSTab::SetCurrentConfig() {

  mCurrentConfig = mWorld->mRobots[mRobotId]->getDofs( mLinks );
  
  std::cout << "Current config: ";
  for( unsigned int i = 0; i < mCurrentConfig.size(); i++ )
    {  std::cout << mCurrentConfig(i) << " ";  } 
  std::cout << std::endl;

  mCurrentPos = GetEE_XYZ( mCurrentConfig );
  std::cout << "Current pos: ";
  std::cout << mCurrentPos << std::endl;

  mJaclin = mEENode->getJacobianLinear().topRightCorner( 3, mLinks.size() );
  FullPivLU<MatrixXd> mJ_LU(mJaclin);
  mNS_Basis = mJ_LU.kernel();

  std::cout << "** Basis NS :\n" << mNS_Basis << std::endl;

  mNS_Dim = mNS_Basis.cols();
  Eigen::MatrixXd normCoeff = Eigen::MatrixXd::Zero( mNS_Dim, mNS_Dim );

  // Normalize
  for( int i = 0; i < mNS_Dim; ++i ) {
    normCoeff(i, i) = (1.0/180.0*3.1416)*1.0/mNS_Basis.col(i).norm();
  }

  mNS_Basis = mNS_Basis*normCoeff;
  std::cout << "** Normalized Basis NS :\n" << mNS_Basis << std::endl;

  //-- Set the coefficients for the nullspace matrix columns
  mNS_Coeff= Eigen::MatrixXd::Zero( mNS_Dim, mNS_Dim );
}


/*
 * @function GetEE_XYZ
 */
Eigen::VectorXd NSTab::GetEE_XYZ( const Eigen::VectorXd &_q ) {

    mWorld->mRobots[mRobotId]->setDofs( _q, mLinks );
    mWorld->mRobots[mRobotId]->update();
    Eigen::MatrixXd pose = mEENode->getWorldTransform(); 
    Eigen::VectorXd xyz(3); xyz << pose(0,3), pose(1,3), pose(2,3);

    return xyz;
}

/**
 * @function OnSlider
 * @brief Handle slider changes
 */
void NSTab::OnSlider(wxCommandEvent &evt) {

    int slnum = evt.GetId();
    double pos = *(double*) evt.GetClientData();
    char numBuf[1000];

    switch (slnum) {

    case slider_NS1:
      sprintf(numBuf, "NS1 Change: %7.4f", pos);
      std::cout << "-->(i) NS1: " << numBuf << std::endl;
      RunOnSliderChange(0, pos); 
      break;
      
    case slider_NS2:
      sprintf(numBuf, "NS2 Change: %7.4f", pos);
      std::cout << "-->(i) NS2: " << numBuf << std::endl;
      RunOnSliderChange(1, pos); 
      break;
      
    case slider_NS3:
      sprintf(numBuf, "NS3 Change: %7.4f", pos);
      std::cout << "-->(i) NS3: " << numBuf << std::endl;
      RunOnSliderChange(2, pos); 
      break;
      
    case slider_NS4:
      sprintf(numBuf, "NS4 Change: %7.4f", pos);
      std::cout << "-->(i) NS4: " << numBuf << std::endl;
      RunOnSliderChange(3, pos); 
      break;
      
    default:
      return;
    }

    //world->updateCollision(o);
    //viewer->UpdateCamera();

    if (frame != NULL)
      frame->SetStatusText(wxString(numBuf, wxConvUTF8));
}

/**
 * @function OnRadio
 */
void NSTab::OnRadio( wxCommandEvent &evt ) {
   
}

/**
 * @function GRIPStateChange -- Keep using this name as it is a virtual function
 * @brief This function is called when an object is selected in the Tree View or other
 *        global changes to the RST world. Use this to capture events from outside the tab.
 */
void NSTab::GRIPStateChange() {
    if ( selectedTreeNode == NULL ) {

        return;
    }

    string statusBuf;
    string buf, buf2;

    switch (selectedTreeNode->dType) {

        case Return_Type_Object:
	          selectedObject = (planning::Object*) ( selectedTreeNode->data );
	          statusBuf = " Selected Object: " + selectedObject->getName();
	          buf = "You clicked on object: " + selectedObject->getName();
	          // Enter action for object select events here:
	          break;

	      case Return_Type_Robot:
	          selectedRobot = (planning::Robot*) ( selectedTreeNode->data );
	          statusBuf = " Selected Robot: " + selectedRobot->getName();
	          buf = " You clicked on robot: " + selectedRobot->getName();
      	    // Enter action for Robot select events here:
	          break;
	      case Return_Type_Node:
	          selectedNode = (kinematics::BodyNode*) ( selectedTreeNode->data );
	          statusBuf = " Selected Body Node: " + string(selectedNode->getName()) + " of Robot: "
			      + ( (planning::Robot*) selectedNode->getSkel() )->getName();
	          buf = " Node: " + string(selectedNode->getName()) + " of Robot: " + ( (planning::Robot*) selectedNode->getSkel() )->getName();
	          // Enter action for link select events here:
      	    break;
        default:
            fprintf(stderr, "--( :D ) Someone else's problem!\n");
            assert(0);
            exit(1);
    }

    //cout << buf << endl;
    frame->SetStatusText(wxString(statusBuf.c_str(), wxConvUTF8));
    sizerFull->Layout();
}
